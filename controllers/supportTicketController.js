const Support = require('../models/supportTicketModel');

const AppError = require('../utils/appError');
const catchAsync = require('../utils/catchAsync');
const multer = require('multer');

const filter = (req, file, cb) => {
  if (file.mimetype.startsWith('image')) {
    cb(null, true);
  } else {
    cb(new AppError('The passed file aint image', 400), false);
  }
};
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, `${__dirname}/../images/support`);
  },
  filename: function (req, file, cb) {
    const ext = file.mimetype.split('/')[1];
    const imgUrlFormat = `user_${req.user.id}_${Date.now()}.${ext}`;

    cb(false, imgUrlFormat);
  },
});

const upload = multer({
  storage,
  fileFilter: filter,
});

exports.addSupportImages = upload.fields([{ name: 'support', maxCount: 4 }]);
///////////////////////////////////////////
// Check new ticker for user
///////////////////////////////////////////
exports.newSupportTicket = catchAsync(async (req, res, next) => {
  //   Check if a ticket with same title is already created by user

  const allTicketsGeneratedByUser = await Support.find({
    user: req.user._id,
  })
    .where('title')
    .equals(req.body.title.trim());
  //   If ticket with same title already genrated show erro
  if (allTicketsGeneratedByUser.length >= 1)
    return next(
      new AppError('Ticket with the same title already generated by you', 403),
    );

  // Generate New Ticket
  const ticketNo =
    String(req.user._id).slice(-2) + String(Date.now()).slice(-4);
  const date = new Date().toLocaleDateString().split('/').join('-');
  // Trim whitespace
  req.body.title.trim();
  req.body.description.trim();
  const media = req.files.support.map((file) => file.filename);
  const supportTicket = await Support.create({
    ...req.body,
    status: 'active',
    ticketNo,
    date,
    media,
    user: req.user._id,
  });

  res.status(201).json({
    status: 'success',
    data: {
      title: supportTicket.title,
      description: supportTicket.description,
      status: supportTicket.status,
      ticketNo: supportTicket.ticketNo,
      date: supportTicket.date,
      media: supportTicket.media,
    },
  });
});
///////////////////////////////////////////
// Get  all tickets by user
///////////////////////////////////////////
exports.getAllTickets = catchAsync(async (req, res, next) => {
  const allTicketsGeneratedByUser = await Support.find({
    user: req.user._id,
  }).select('-_id -__v -user -media -description');

  res.status(200).json({
    status: 'successs',
    totalTickets: allTicketsGeneratedByUser.length,
    data: allTicketsGeneratedByUser,
  });
});
///////////////////////////////////////////
// Get  all tickets for  admin
///////////////////////////////////////////
exports.getTicketsForAdmin = catchAsync(async (req, res, next) => {
  const allTickets = await Support.find().populate('user', 'email');

  res.status(200).json({
    status: 'success',
    noOfTickets: allTickets.length,
    allTickets,
  });
});
///////////////////////////////////////////
// Update Status of ticket
///////////////////////////////////////////
exports.upodateTicket = catchAsync(async (req, res, next) => {
  const { ticketId, status } = req.body;

  if (!ticketId || !status) return next(new AppError('Not found'), 404);
  const check = await Support.findOneAndUpdate(
    { _id: ticketId },
    { status: status },
    {
      new: true,
    },
  );
  if (!check) return next(new AppError('Ticket not found', 404));
  res.status(201).json({
    status: 'success',
    message: 'ticket updated successfully',
  });
});
exports.deleteTicket = catchAsync(async (req, res, next) => {
  const { ticketId } = req.body;

  if (!ticketId) return next(new AppError('Not found'), 404);
  await Support.findOneAndDelete({ _id: ticketId });
  res.status(204).json({
    status: 'success',
    message: 'ticket deleted successfully',
  });
});
